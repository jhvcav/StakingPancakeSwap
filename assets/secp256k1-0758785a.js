import{v as He,w as Le,x as Te,y as Jt,z as Ue,C as ke,D as le,E as St}from"./index-a7e8a81f.js";class de extends He{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,Le(n);const r=Te(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,o=new Uint8Array(i);o.set(r.length>i?n.create().update(r).digest():r);for(let c=0;c<o.length;c++)o[c]^=54;this.iHash.update(o),this.oHash=n.create();for(let c=0;c<o.length;c++)o[c]^=106;this.oHash.update(o),o.fill(0)}update(n){return Jt(this),this.iHash.update(n),this}digestInto(n){Jt(this),Ue(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:i,destroyed:o,blockLen:c,outputLen:f}=this;return n=n,n.finished=i,n.destroyed=o,n.blockLen=c,n.outputLen=f,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const he=(t,n,e)=>new de(t,n).update(e).digest();he.create=(t,n)=>new de(t,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Wt=BigInt(0),Mt=BigInt(1);function dt(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function et(t){if(!dt(t))throw new Error("Uint8Array expected")}function gt(t,n){if(typeof n!="boolean")throw new Error(t+" boolean expected, got "+n)}function Bt(t){const n=t.toString(16);return n.length&1?"0"+n:n}function we(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?Wt:BigInt("0x"+t)}const ge=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Ze=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function mt(t){if(et(t),ge)return t.toHex();let n="";for(let e=0;e<t.length;e++)n+=Ze[t[e]];return n}const X={_0:48,_9:57,A:65,F:70,a:97,f:102};function Ft(t){if(t>=X._0&&t<=X._9)return t-X._0;if(t>=X.A&&t<=X.F)return t-(X.A-10);if(t>=X.a&&t<=X.f)return t-(X.a-10)}function At(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(ge)return Uint8Array.fromHex(t);const n=t.length,e=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let i=0,o=0;i<e;i++,o+=2){const c=Ft(t.charCodeAt(o)),f=Ft(t.charCodeAt(o+1));if(c===void 0||f===void 0){const s=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+s+'" at index '+o)}r[i]=c*16+f}return r}function G(t){return we(mt(t))}function me(t){return et(t),we(mt(Uint8Array.from(t).reverse()))}function ct(t,n){return At(t.toString(16).padStart(n*2,"0"))}function ye(t,n){return ct(t,n).reverse()}function z(t,n,e){let r;if(typeof n=="string")try{r=At(n)}catch(o){throw new Error(t+" must be hex string or Uint8Array, cause: "+o)}else if(dt(n))r=Uint8Array.from(n);else throw new Error(t+" must be hex string or Uint8Array");const i=r.length;if(typeof e=="number"&&i!==e)throw new Error(t+" of length "+e+" expected, got "+i);return r}function Y(...t){let n=0;for(let r=0;r<t.length;r++){const i=t[r];et(i),n+=i.length}const e=new Uint8Array(n);for(let r=0,i=0;r<t.length;r++){const o=t[r];e.set(o,i),i+=o.length}return e}function Gt(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}const Tt=t=>typeof t=="bigint"&&Wt<=t;function yt(t,n,e){return Tt(t)&&Tt(n)&&Tt(e)&&n<=t&&t<e}function st(t,n,e,r){if(!yt(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}function Ce(t){let n;for(n=0;t>Wt;t>>=Mt,n+=1);return n}const Nt=t=>(Mt<<BigInt(t))-Mt,Ut=t=>new Uint8Array(t),te=t=>Uint8Array.from(t);function ze(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Ut(t),i=Ut(t),o=0;const c=()=>{r.fill(1),i.fill(0),o=0},f=(...m)=>e(i,r,...m),s=(m=Ut(0))=>{i=f(te([0]),m),r=f(),m.length!==0&&(i=f(te([1]),m),r=f())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let m=0;const d=[];for(;m<n;){r=f();const b=r.slice();d.push(b),m+=r.length}return Y(...d)};return(m,d)=>{c(),s(m);let b;for(;!(b=d(u()));)s();return c(),b}}const Ve={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||dt(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function vt(t,n,e={}){const r=(i,o,c)=>{const f=Ve[o];if(typeof f!="function")throw new Error("invalid validator function");const s=t[i];if(!(c&&s===void 0)&&!f(s,t))throw new Error("param "+String(i)+" is invalid. Expected "+o+", got "+s)};for(const[i,o]of Object.entries(n))r(i,o,!1);for(const[i,o]of Object.entries(e))r(i,o,!0);return t}function ee(t){const n=new WeakMap;return(e,...r)=>{const i=n.get(e);if(i!==void 0)return i;const o=t(e,...r);return n.set(e,o),o}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Z=BigInt(0),T=BigInt(1),it=BigInt(2),Me=BigInt(3),Pt=BigInt(4),ne=BigInt(5),re=BigInt(8);function k(t,n){const e=t%n;return e>=Z?e:n+e}function Pe(t,n,e){if(n<Z)throw new Error("invalid exponent, negatives unsupported");if(e<=Z)throw new Error("invalid modulus");if(e===T)return Z;let r=T;for(;n>Z;)n&T&&(r=r*t%e),t=t*t%e,n>>=T;return r}function K(t,n,e){let r=t;for(;n-- >Z;)r*=r,r%=e;return r}function jt(t,n){if(t===Z)throw new Error("invert: expected non-zero number");if(n<=Z)throw new Error("invert: expected positive modulus, got "+n);let e=k(t,n),r=n,i=Z,o=T;for(;e!==Z;){const f=r/e,s=r%e,u=i-o*f;r=e,e=s,i=o,o=u}if(r!==T)throw new Error("invert: does not exist");return k(i,n)}function je(t){const n=(t-T)/it;let e,r,i;for(e=t-T,r=0;e%it===Z;e/=it,r++);for(i=it;i<t&&Pe(i,n,t)!==t-T;i++)if(i>1e3)throw new Error("Cannot find square root: likely non-prime P");if(r===1){const c=(t+T)/Pt;return function(s,u){const h=s.pow(u,c);if(!s.eql(s.sqr(h),u))throw new Error("Cannot find square root");return h}}const o=(e+T)/it;return function(f,s){if(f.pow(s,n)===f.neg(f.ONE))throw new Error("Cannot find square root");let u=r,h=f.pow(f.mul(f.ONE,i),e),m=f.pow(s,o),d=f.pow(s,e);for(;!f.eql(d,f.ONE);){if(f.eql(d,f.ZERO))return f.ZERO;let b=1;for(let E=f.sqr(d);b<u&&!f.eql(E,f.ONE);b++)E=f.sqr(E);const _=f.pow(h,T<<BigInt(u-b-1));h=f.sqr(_),m=f.mul(m,_),d=f.mul(d,h),u=b}return m}}function Ke(t){if(t%Pt===Me){const n=(t+T)/Pt;return function(r,i){const o=r.pow(i,n);if(!r.eql(r.sqr(o),i))throw new Error("Cannot find square root");return o}}if(t%re===ne){const n=(t-ne)/re;return function(r,i){const o=r.mul(i,it),c=r.pow(o,n),f=r.mul(i,c),s=r.mul(r.mul(f,it),c),u=r.mul(f,r.sub(s,r.ONE));if(!r.eql(r.sqr(u),i))throw new Error("Cannot find square root");return u}}return je(t)}const Ye=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function be(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Ye.reduce((r,i)=>(r[i]="function",r),n);return vt(t,e)}function De(t,n,e){if(e<Z)throw new Error("invalid exponent, negatives unsupported");if(e===Z)return t.ONE;if(e===T)return n;let r=t.ONE,i=n;for(;e>Z;)e&T&&(r=t.mul(r,i)),i=t.sqr(i),e>>=T;return r}function We(t,n){const e=new Array(n.length),r=n.reduce((o,c,f)=>t.is0(c)?o:(e[f]=o,t.mul(o,c)),t.ONE),i=t.inv(r);return n.reduceRight((o,c,f)=>t.is0(c)?o:(e[f]=t.mul(o,e[f]),t.mul(o,c)),i),e}function pe(t,n){const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function Ee(t,n,e=!1,r={}){if(t<=Z)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:i,nByteLength:o}=pe(t,n);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const f=Object.freeze({ORDER:t,isLE:e,BITS:i,BYTES:o,MASK:Nt(i),ZERO:Z,ONE:T,create:s=>k(s,t),isValid:s=>{if(typeof s!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof s);return Z<=s&&s<t},is0:s=>s===Z,isOdd:s=>(s&T)===T,neg:s=>k(-s,t),eql:(s,u)=>s===u,sqr:s=>k(s*s,t),add:(s,u)=>k(s+u,t),sub:(s,u)=>k(s-u,t),mul:(s,u)=>k(s*u,t),pow:(s,u)=>De(f,s,u),div:(s,u)=>k(s*jt(u,t),t),sqrN:s=>s*s,addN:(s,u)=>s+u,subN:(s,u)=>s-u,mulN:(s,u)=>s*u,inv:s=>jt(s,t),sqrt:r.sqrt||(s=>(c||(c=Ke(t)),c(f,s))),invertBatch:s=>We(f,s),cmov:(s,u,h)=>h?u:s,toBytes:s=>e?ye(s,o):ct(s,o),fromBytes:s=>{if(s.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+s.length);return e?me(s):G(s)}});return Object.freeze(f)}function ve(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function xe(t){const n=ve(t);return n+Math.ceil(n/2)}function Ge(t,n,e=!1){const r=t.length,i=ve(n),o=xe(n);if(r<16||r<o||r>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+r);const c=e?me(t):G(t),f=k(c,n-T)+T;return e?ye(f,i):ct(f,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const oe=BigInt(0),Kt=BigInt(1);function kt(t,n){const e=n.negate();return t?e:n}function Be(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function Zt(t,n){Be(t,n);const e=Math.ceil(n/t)+1,r=2**(t-1),i=2**t,o=Nt(t),c=BigInt(t);return{windows:e,windowSize:r,mask:o,maxNumber:i,shiftBy:c}}function ie(t,n,e){const{windowSize:r,mask:i,maxNumber:o,shiftBy:c}=e;let f=Number(t&i),s=t>>c;f>r&&(f-=o,s+=Kt);const u=n*r,h=u+Math.abs(f)-1,m=f===0,d=f<0,b=n%2!==0;return{nextN:s,offset:h,isZero:m,isNeg:d,isNegF:b,offsetF:u}}function $e(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function Xe(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}const Ct=new WeakMap,Se=new WeakMap;function zt(t){return Se.get(t)||1}function Qe(t,n){return{constTimeNegate:kt,hasPrecomputes(e){return zt(e)!==1},unsafeLadder(e,r,i=t.ZERO){let o=e;for(;r>oe;)r&Kt&&(i=i.add(o)),o=o.double(),r>>=Kt;return i},precomputeWindow(e,r){const{windows:i,windowSize:o}=Zt(r,n),c=[];let f=e,s=f;for(let u=0;u<i;u++){s=f,c.push(s);for(let h=1;h<o;h++)s=s.add(f),c.push(s);f=s.double()}return c},wNAF(e,r,i){let o=t.ZERO,c=t.BASE;const f=Zt(e,n);for(let s=0;s<f.windows;s++){const{nextN:u,offset:h,isZero:m,isNeg:d,isNegF:b,offsetF:_}=ie(i,s,f);i=u,m?c=c.add(kt(b,r[_])):o=o.add(kt(d,r[h]))}return{p:o,f:c}},wNAFUnsafe(e,r,i,o=t.ZERO){const c=Zt(e,n);for(let f=0;f<c.windows&&i!==oe;f++){const{nextN:s,offset:u,isZero:h,isNeg:m}=ie(i,f,c);if(i=s,!h){const d=r[u];o=o.add(m?d.negate():d)}}return o},getPrecomputes(e,r,i){let o=Ct.get(r);return o||(o=this.precomputeWindow(r,e),e!==1&&Ct.set(r,i(o))),o},wNAFCached(e,r,i){const o=zt(e);return this.wNAF(o,this.getPrecomputes(o,e,i),r)},wNAFCachedUnsafe(e,r,i,o){const c=zt(e);return c===1?this.unsafeLadder(e,r,o):this.wNAFUnsafe(c,this.getPrecomputes(c,e,i),r,o)},setWindowSize(e,r){Be(r,n),Se.set(e,r),Ct.delete(e)}}}function Je(t,n,e,r){if($e(e,t),Xe(r,n),e.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const i=t.ZERO,o=Ce(BigInt(e.length)),c=o>12?o-3:o>4?o-2:o?2:1,f=Nt(c),s=new Array(Number(f)+1).fill(i),u=Math.floor((n.BITS-1)/c)*c;let h=i;for(let m=u;m>=0;m-=c){s.fill(i);for(let b=0;b<r.length;b++){const _=r[b],E=Number(_>>BigInt(m)&f);s[E]=s[E].add(e[b])}let d=i;for(let b=s.length-1,_=i;b>0;b--)_=_.add(s[b]),d=d.add(_);if(h=h.add(d),m!==0)for(let b=0;b<c;b++)h=h.double()}return h}function Ae(t){return be(t.Fp),vt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...pe(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function se(t){t.lowS!==void 0&&gt("lowS",t.lowS),t.prehash!==void 0&&gt("prehash",t.prehash)}function Fe(t){const n=Ae(t);vt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:i}=n;if(e){if(!r.eql(i,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...n})}class tn extends Error{constructor(n=""){super(n)}}const Q={Err:tn,_tlv:{encode:(t,n)=>{const{Err:e}=Q;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length&1)throw new e("tlv.encode: unpadded data");const r=n.length/2,i=Bt(r);if(i.length/2&128)throw new e("tlv.encode: long form length too big");const o=r>127?Bt(i.length/2|128):"";return Bt(t)+o+i+n},decode(t,n){const{Err:e}=Q;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const i=n[r++],o=!!(i&128);let c=0;if(!o)c=i;else{const s=i&127;if(!s)throw new e("tlv.decode(long): indefinite length not supported");if(s>4)throw new e("tlv.decode(long): byte length is too big");const u=n.subarray(r,r+s);if(u.length!==s)throw new e("tlv.decode: length bytes not complete");if(u[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const h of u)c=c<<8|h;if(r+=s,c<128)throw new e("tlv.decode(long): not minimal encoding")}const f=n.subarray(r,r+c);if(f.length!==c)throw new e("tlv.decode: wrong value length");return{v:f,l:n.subarray(r+c)}}},_int:{encode(t){const{Err:n}=Q;if(t<W)throw new n("integer: negative integers are not allowed");let e=Bt(t);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){const{Err:n}=Q;if(t[0]&128)throw new n("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return G(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=Q,i=z("signature",t),{v:o,l:c}=r.decode(48,i);if(c.length)throw new n("invalid signature: left bytes after parsing");const{v:f,l:s}=r.decode(2,o),{v:u,l:h}=r.decode(2,s);if(h.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(f),s:e.decode(u)}},hexFromSig(t){const{_tlv:n,_int:e}=Q,r=n.encode(2,e.encode(t.r)),i=n.encode(2,e.encode(t.s)),o=r+i;return n.encode(48,o)}},W=BigInt(0),H=BigInt(1),F=BigInt(2),It=BigInt(3),ce=BigInt(4);function en(t){const n=Fe(t),{Fp:e}=n,r=Ee(n.n,n.nBitLength),i=n.toBytes||((E,a,l)=>{const g=a.toAffine();return Y(Uint8Array.from([4]),e.toBytes(g.x),e.toBytes(g.y))}),o=n.fromBytes||(E=>{const a=E.subarray(1),l=e.fromBytes(a.subarray(0,e.BYTES)),g=e.fromBytes(a.subarray(e.BYTES,2*e.BYTES));return{x:l,y:g}});function c(E){const{a,b:l}=n,g=e.sqr(E),y=e.mul(g,E);return e.add(e.add(y,e.mul(E,a)),l)}if(!e.eql(e.sqr(n.Gy),c(n.Gx)))throw new Error("bad generator point: equation left != right");function f(E){return yt(E,H,n.n)}function s(E){const{allowedPrivateKeyLengths:a,nByteLength:l,wrapPrivateKey:g,n:y}=n;if(a&&typeof E!="bigint"){if(dt(E)&&(E=mt(E)),typeof E!="string"||!a.includes(E.length))throw new Error("invalid private key");E=E.padStart(l*2,"0")}let x;try{x=typeof E=="bigint"?E:G(z("private key",E,l))}catch{throw new Error("invalid private key, expected hex or "+l+" bytes, got "+typeof E)}return g&&(x=k(x,y)),st("private key",x,H,y),x}function u(E){if(!(E instanceof d))throw new Error("ProjectivePoint expected")}const h=ee((E,a)=>{const{px:l,py:g,pz:y}=E;if(e.eql(y,e.ONE))return{x:l,y:g};const x=E.is0();a==null&&(a=x?e.ONE:e.inv(y));const q=e.mul(l,a),I=e.mul(g,a),B=e.mul(y,a);if(x)return{x:e.ZERO,y:e.ZERO};if(!e.eql(B,e.ONE))throw new Error("invZ was invalid");return{x:q,y:I}}),m=ee(E=>{if(E.is0()){if(n.allowInfinityPoint&&!e.is0(E.py))return;throw new Error("bad point: ZERO")}const{x:a,y:l}=E.toAffine();if(!e.isValid(a)||!e.isValid(l))throw new Error("bad point: x or y not FE");const g=e.sqr(l),y=c(a);if(!e.eql(g,y))throw new Error("bad point: equation left != right");if(!E.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class d{constructor(a,l,g){if(a==null||!e.isValid(a))throw new Error("x required");if(l==null||!e.isValid(l))throw new Error("y required");if(g==null||!e.isValid(g))throw new Error("z required");this.px=a,this.py=l,this.pz=g,Object.freeze(this)}static fromAffine(a){const{x:l,y:g}=a||{};if(!a||!e.isValid(l)||!e.isValid(g))throw new Error("invalid affine point");if(a instanceof d)throw new Error("projective point not allowed");const y=x=>e.eql(x,e.ZERO);return y(l)&&y(g)?d.ZERO:new d(l,g,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){const l=e.invertBatch(a.map(g=>g.pz));return a.map((g,y)=>g.toAffine(l[y])).map(d.fromAffine)}static fromHex(a){const l=d.fromAffine(o(z("pointHex",a)));return l.assertValidity(),l}static fromPrivateKey(a){return d.BASE.multiply(s(a))}static msm(a,l){return Je(d,r,a,l)}_setWindowSize(a){_.setWindowSize(this,a)}assertValidity(){m(this)}hasEvenY(){const{y:a}=this.toAffine();if(e.isOdd)return!e.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){u(a);const{px:l,py:g,pz:y}=this,{px:x,py:q,pz:I}=a,B=e.eql(e.mul(l,I),e.mul(x,y)),A=e.eql(e.mul(g,I),e.mul(q,y));return B&&A}negate(){return new d(this.px,e.neg(this.py),this.pz)}double(){const{a,b:l}=n,g=e.mul(l,It),{px:y,py:x,pz:q}=this;let I=e.ZERO,B=e.ZERO,A=e.ZERO,S=e.mul(y,y),C=e.mul(x,x),L=e.mul(q,q),R=e.mul(y,x);return R=e.add(R,R),A=e.mul(y,q),A=e.add(A,A),I=e.mul(a,A),B=e.mul(g,L),B=e.add(I,B),I=e.sub(C,B),B=e.add(C,B),B=e.mul(I,B),I=e.mul(R,I),A=e.mul(g,A),L=e.mul(a,L),R=e.sub(S,L),R=e.mul(a,R),R=e.add(R,A),A=e.add(S,S),S=e.add(A,S),S=e.add(S,L),S=e.mul(S,R),B=e.add(B,S),L=e.mul(x,q),L=e.add(L,L),S=e.mul(L,R),I=e.sub(I,S),A=e.mul(L,C),A=e.add(A,A),A=e.add(A,A),new d(I,B,A)}add(a){u(a);const{px:l,py:g,pz:y}=this,{px:x,py:q,pz:I}=a;let B=e.ZERO,A=e.ZERO,S=e.ZERO;const C=n.a,L=e.mul(n.b,It);let R=e.mul(l,x),j=e.mul(g,q),w=e.mul(y,I),p=e.add(l,g),v=e.add(x,q);p=e.mul(p,v),v=e.add(R,j),p=e.sub(p,v),v=e.add(l,y);let O=e.add(x,I);return v=e.mul(v,O),O=e.add(R,w),v=e.sub(v,O),O=e.add(g,y),B=e.add(q,I),O=e.mul(O,B),B=e.add(j,w),O=e.sub(O,B),S=e.mul(C,v),B=e.mul(L,w),S=e.add(B,S),B=e.sub(j,S),S=e.add(j,S),A=e.mul(B,S),j=e.add(R,R),j=e.add(j,R),w=e.mul(C,w),v=e.mul(L,v),j=e.add(j,w),w=e.sub(R,w),w=e.mul(C,w),v=e.add(v,w),R=e.mul(j,v),A=e.add(A,R),R=e.mul(O,v),B=e.mul(p,B),B=e.sub(B,R),R=e.mul(p,j),S=e.mul(O,S),S=e.add(S,R),new d(B,A,S)}subtract(a){return this.add(a.negate())}is0(){return this.equals(d.ZERO)}wNAF(a){return _.wNAFCached(this,a,d.normalizeZ)}multiplyUnsafe(a){const{endo:l,n:g}=n;st("scalar",a,W,g);const y=d.ZERO;if(a===W)return y;if(this.is0()||a===H)return this;if(!l||_.hasPrecomputes(this))return _.wNAFCachedUnsafe(this,a,d.normalizeZ);let{k1neg:x,k1:q,k2neg:I,k2:B}=l.splitScalar(a),A=y,S=y,C=this;for(;q>W||B>W;)q&H&&(A=A.add(C)),B&H&&(S=S.add(C)),C=C.double(),q>>=H,B>>=H;return x&&(A=A.negate()),I&&(S=S.negate()),S=new d(e.mul(S.px,l.beta),S.py,S.pz),A.add(S)}multiply(a){const{endo:l,n:g}=n;st("scalar",a,H,g);let y,x;if(l){const{k1neg:q,k1:I,k2neg:B,k2:A}=l.splitScalar(a);let{p:S,f:C}=this.wNAF(I),{p:L,f:R}=this.wNAF(A);S=_.constTimeNegate(q,S),L=_.constTimeNegate(B,L),L=new d(e.mul(L.px,l.beta),L.py,L.pz),y=S.add(L),x=C.add(R)}else{const{p:q,f:I}=this.wNAF(a);y=q,x=I}return d.normalizeZ([y,x])[0]}multiplyAndAddUnsafe(a,l,g){const y=d.BASE,x=(I,B)=>B===W||B===H||!I.equals(y)?I.multiplyUnsafe(B):I.multiply(B),q=x(this,l).add(x(a,g));return q.is0()?void 0:q}toAffine(a){return h(this,a)}isTorsionFree(){const{h:a,isTorsionFree:l}=n;if(a===H)return!0;if(l)return l(d,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:a,clearCofactor:l}=n;return a===H?this:l?l(d,this):this.multiplyUnsafe(n.h)}toRawBytes(a=!0){return gt("isCompressed",a),this.assertValidity(),i(d,this,a)}toHex(a=!0){return gt("isCompressed",a),mt(this.toRawBytes(a))}}d.BASE=new d(n.Gx,n.Gy,e.ONE),d.ZERO=new d(e.ZERO,e.ONE,e.ZERO);const b=n.nBitLength,_=Qe(d,n.endo?Math.ceil(b/2):b);return{CURVE:n,ProjectivePoint:d,normPrivateKeyToScalar:s,weierstrassEquation:c,isWithinCurveOrder:f}}function nn(t){const n=Ae(t);return vt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function rn(t){const n=nn(t),{Fp:e,n:r}=n,i=e.BYTES+1,o=2*e.BYTES+1;function c(w){return k(w,r)}function f(w){return jt(w,r)}const{ProjectivePoint:s,normPrivateKeyToScalar:u,weierstrassEquation:h,isWithinCurveOrder:m}=en({...n,toBytes(w,p,v){const O=p.toAffine(),N=e.toBytes(O.x),U=Y;return gt("isCompressed",v),v?U(Uint8Array.from([p.hasEvenY()?2:3]),N):U(Uint8Array.from([4]),N,e.toBytes(O.y))},fromBytes(w){const p=w.length,v=w[0],O=w.subarray(1);if(p===i&&(v===2||v===3)){const N=G(O);if(!yt(N,H,e.ORDER))throw new Error("Point is not on curve");const U=h(N);let M;try{M=e.sqrt(U)}catch(D){const P=D instanceof Error?": "+D.message:"";throw new Error("Point is not on curve"+P)}const V=(M&H)===H;return(v&1)===1!==V&&(M=e.neg(M)),{x:N,y:M}}else if(p===o&&v===4){const N=e.fromBytes(O.subarray(0,e.BYTES)),U=e.fromBytes(O.subarray(e.BYTES,2*e.BYTES));return{x:N,y:U}}else{const N=i,U=o;throw new Error("invalid Point, expected length of "+N+", or uncompressed "+U+", got "+p)}}}),d=w=>mt(ct(w,n.nByteLength));function b(w){const p=r>>H;return w>p}function _(w){return b(w)?c(-w):w}const E=(w,p,v)=>G(w.slice(p,v));class a{constructor(p,v,O){st("r",p,H,r),st("s",v,H,r),this.r=p,this.s=v,O!=null&&(this.recovery=O),Object.freeze(this)}static fromCompact(p){const v=n.nByteLength;return p=z("compactSignature",p,v*2),new a(E(p,0,v),E(p,v,2*v))}static fromDER(p){const{r:v,s:O}=Q.toSig(z("DER",p));return new a(v,O)}assertValidity(){}addRecoveryBit(p){return new a(this.r,this.s,p)}recoverPublicKey(p){const{r:v,s:O,recovery:N}=this,U=I(z("msgHash",p));if(N==null||![0,1,2,3].includes(N))throw new Error("recovery id invalid");const M=N===2||N===3?v+n.n:v;if(M>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const V=N&1?"03":"02",$=s.fromHex(V+d(M)),D=f(M),P=c(-U*D),ft=c(O*D),J=s.BASE.multiplyAndAddUnsafe($,P,ft);if(!J)throw new Error("point at infinify");return J.assertValidity(),J}hasHighS(){return b(this.s)}normalizeS(){return this.hasHighS()?new a(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return At(this.toDERHex())}toDERHex(){return Q.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return At(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}const l={isValidPrivateKey(w){try{return u(w),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const w=xe(n.n);return Ge(n.randomBytes(w),n.n)},precompute(w=8,p=s.BASE){return p._setWindowSize(w),p.multiply(BigInt(3)),p}};function g(w,p=!0){return s.fromPrivateKey(w).toRawBytes(p)}function y(w){const p=dt(w),v=typeof w=="string",O=(p||v)&&w.length;return p?O===i||O===o:v?O===2*i||O===2*o:w instanceof s}function x(w,p,v=!0){if(y(w))throw new Error("first arg must be private key");if(!y(p))throw new Error("second arg must be public key");return s.fromHex(p).multiply(u(w)).toRawBytes(v)}const q=n.bits2int||function(w){if(w.length>8192)throw new Error("input is too large");const p=G(w),v=w.length*8-n.nBitLength;return v>0?p>>BigInt(v):p},I=n.bits2int_modN||function(w){return c(q(w))},B=Nt(n.nBitLength);function A(w){return st("num < 2^"+n.nBitLength,w,W,B),ct(w,n.nByteLength)}function S(w,p,v=C){if(["recovered","canonical"].some(rt=>rt in v))throw new Error("sign() legacy options not supported");const{hash:O,randomBytes:N}=n;let{lowS:U,prehash:M,extraEntropy:V}=v;U==null&&(U=!0),w=z("msgHash",w),se(v),M&&(w=z("prehashed msgHash",O(w)));const $=I(w),D=u(p),P=[A(D),A($)];if(V!=null&&V!==!1){const rt=V===!0?N(e.BYTES):V;P.push(z("extraEntropy",rt))}const ft=Y(...P),J=$;function Ht(rt){const at=q(rt);if(!m(at))return;const Lt=f(at),ht=s.BASE.multiply(at).toAffine(),ot=c(ht.x);if(ot===W)return;const wt=c(Lt*c(J+ot*D));if(wt===W)return;let ut=(ht.x===ot?0:2)|Number(ht.y&H),Qt=wt;return U&&b(wt)&&(Qt=_(wt),ut^=1),new a(ot,Qt,ut)}return{seed:ft,k2sig:Ht}}const C={lowS:n.lowS,prehash:!1},L={lowS:n.lowS,prehash:!1};function R(w,p,v=C){const{seed:O,k2sig:N}=S(w,p,v),U=n;return ze(U.hash.outputLen,U.nByteLength,U.hmac)(O,N)}s.BASE._setWindowSize(8);function j(w,p,v,O=L){const N=w;p=z("msgHash",p),v=z("publicKey",v);const{lowS:U,prehash:M,format:V}=O;if(se(O),"strict"in O)throw new Error("options.strict was renamed to lowS");if(V!==void 0&&V!=="compact"&&V!=="der")throw new Error("format must be compact or der");const $=typeof N=="string"||dt(N),D=!$&&!V&&typeof N=="object"&&N!==null&&typeof N.r=="bigint"&&typeof N.s=="bigint";if(!$&&!D)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let P,ft;try{if(D&&(P=new a(N.r,N.s)),$){try{V!=="compact"&&(P=a.fromDER(N))}catch(ut){if(!(ut instanceof Q.Err))throw ut}!P&&V!=="der"&&(P=a.fromCompact(N))}ft=s.fromHex(v)}catch{return!1}if(!P||U&&P.hasHighS())return!1;M&&(p=n.hash(p));const{r:J,s:Ht}=P,rt=I(p),at=f(Ht),Lt=c(rt*at),ht=c(J*at),ot=s.BASE.multiplyAndAddUnsafe(ft,Lt,ht)?.toAffine();return ot?c(ot.x)===J:!1}return{CURVE:n,getPublicKey:g,getSharedSecret:x,sign:R,verify:j,ProjectivePoint:s,Signature:a,utils:l}}function on(t,n){const e=t.ORDER;let r=W;for(let _=e-H;_%F===W;_/=F)r+=H;const i=r,o=F<<i-H-H,c=o*F,f=(e-H)/c,s=(f-H)/F,u=c-H,h=o,m=t.pow(n,f),d=t.pow(n,(f+H)/F);let b=(_,E)=>{let a=m,l=t.pow(E,u),g=t.sqr(l);g=t.mul(g,E);let y=t.mul(_,g);y=t.pow(y,s),y=t.mul(y,l),l=t.mul(y,E),g=t.mul(y,_);let x=t.mul(g,l);y=t.pow(x,h);let q=t.eql(y,t.ONE);l=t.mul(g,d),y=t.mul(x,a),g=t.cmov(l,g,q),x=t.cmov(y,x,q);for(let I=i;I>H;I--){let B=I-F;B=F<<B-H;let A=t.pow(x,B);const S=t.eql(A,t.ONE);l=t.mul(g,a),a=t.mul(a,a),A=t.mul(x,a),g=t.cmov(l,g,S),x=t.cmov(A,x,S)}return{isValid:q,value:g}};if(t.ORDER%ce===It){const _=(t.ORDER-It)/ce,E=t.sqrt(t.neg(n));b=(a,l)=>{let g=t.sqr(l);const y=t.mul(a,l);g=t.mul(g,y);let x=t.pow(g,_);x=t.mul(x,y);const q=t.mul(x,E),I=t.mul(t.sqr(x),l),B=t.eql(I,a);let A=t.cmov(q,x,B);return{isValid:B,value:A}}}return b}function sn(t,n){if(be(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=on(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let i,o,c,f,s,u,h,m;i=t.sqr(r),i=t.mul(i,n.Z),o=t.sqr(i),o=t.add(o,i),c=t.add(o,t.ONE),c=t.mul(c,n.B),f=t.cmov(n.Z,t.neg(o),!t.eql(o,t.ZERO)),f=t.mul(f,n.A),o=t.sqr(c),u=t.sqr(f),s=t.mul(u,n.A),o=t.add(o,s),o=t.mul(o,c),u=t.mul(u,f),s=t.mul(u,n.B),o=t.add(o,s),h=t.mul(i,c);const{isValid:d,value:b}=e(o,u);m=t.mul(i,r),m=t.mul(m,b),h=t.cmov(h,c,d),m=t.cmov(m,b,d);const _=t.isOdd(r)===t.isOdd(m);return m=t.cmov(t.neg(m),m,_),h=t.div(h,f),{x:h,y:m}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function cn(t){return{hash:t,hmac:(n,...e)=>he(t,n,ke(...e)),randomBytes:le}}function fn(t,n){const e=r=>rn({...t,...cn(r)});return{...e(n),create:e}}const an=G;function tt(t,n){if(bt(t),bt(n),t<0||t>=1<<8*n)throw new Error("invalid I2OSP input: "+t);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function un(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function bt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function ln(t,n,e,r){et(t),et(n),bt(e),n.length>255&&(n=r(Y(Gt("H2C-OVERSIZE-DST-"),n)));const{outputLen:i,blockLen:o}=r,c=Math.ceil(e/i);if(e>65535||c>255)throw new Error("expand_message_xmd: invalid lenInBytes");const f=Y(n,tt(n.length,1)),s=tt(0,o),u=tt(e,2),h=new Array(c),m=r(Y(s,t,u,tt(0,1),f));h[0]=r(Y(m,tt(1,1),f));for(let b=1;b<=c;b++){const _=[un(m,h[b-1]),tt(b+1,1),f];h[b]=r(Y(..._))}return Y(...h).slice(0,e)}function dn(t,n,e,r,i){if(et(t),et(n),bt(e),n.length>255){const o=Math.ceil(2*r/8);n=i.create({dkLen:o}).update(Gt("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return i.create({dkLen:e}).update(t).update(tt(e,2)).update(n).update(tt(n.length,1)).digest()}function fe(t,n,e){vt(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:i,m:o,hash:c,expand:f,DST:s}=e;et(t),bt(n);const u=typeof s=="string"?Gt(s):s,h=r.toString(2).length,m=Math.ceil((h+i)/8),d=n*o*m;let b;if(f==="xmd")b=ln(t,u,d,c);else if(f==="xof")b=dn(t,u,d,i,c);else if(f==="_internal_pass")b=t;else throw new Error('expand must be "xmd" or "xof"');const _=new Array(n);for(let E=0;E<n;E++){const a=new Array(o);for(let l=0;l<o;l++){const g=m*(l+E*o),y=b.subarray(g,g+m);a[l]=k(an(y),r)}_[E]=a}return _}function hn(t,n){const e=n.map(r=>Array.from(r).reverse());return(r,i)=>{const[o,c,f,s]=e.map(u=>u.reduce((h,m)=>t.add(t.mul(h,r),m)));if(t.is0(c)||t.is0(s))throw new Error("bad point: ZERO");return r=t.div(o,c),i=t.mul(i,t.div(f,s)),{x:r,y:i}}}function wn(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,i){const o=fe(r,2,{...e,DST:e.DST,...i}),c=t.fromAffine(n(o[0])),f=t.fromAffine(n(o[1])),s=c.add(f).clearCofactor();return s.assertValidity(),s},encodeToCurve(r,i){const o=fe(r,1,{...e,DST:e.encodeDST,...i}),c=t.fromAffine(n(o[0])).clearCofactor();return c.assertValidity(),c},mapToCurve(r){if(!Array.isArray(r))throw new Error("mapToCurve: expected array of bigints");for(const o of r)if(typeof o!="bigint")throw new Error("mapToCurve: expected array of bigints");const i=t.fromAffine(n(r)).clearCofactor();return i.assertValidity(),i}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const xt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),_t=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),pt=BigInt(1),Ot=BigInt(2),ae=(t,n)=>(t+n/Ot)/n;function Ie(t){const n=xt,e=BigInt(3),r=BigInt(6),i=BigInt(11),o=BigInt(22),c=BigInt(23),f=BigInt(44),s=BigInt(88),u=t*t*t%n,h=u*u*t%n,m=K(h,e,n)*h%n,d=K(m,e,n)*h%n,b=K(d,Ot,n)*u%n,_=K(b,i,n)*b%n,E=K(_,o,n)*_%n,a=K(E,f,n)*E%n,l=K(a,s,n)*a%n,g=K(l,f,n)*E%n,y=K(g,e,n)*h%n,x=K(y,c,n)*_%n,q=K(x,r,n)*u%n,I=K(q,Ot,n);if(!nt.eql(nt.sqr(I),t))throw new Error("Cannot find square root");return I}const nt=Ee(xt,void 0,void 0,{sqrt:Ie}),Rt=fn({a:BigInt(0),b:BigInt(7),Fp:nt,n:_t,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=_t,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-pt*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=e,c=BigInt("0x100000000000000000000000000000000"),f=ae(o*t,n),s=ae(-r*t,n);let u=k(t-f*e-s*i,n),h=k(-f*r-s*o,n);const m=u>c,d=h>c;if(m&&(u=n-u),d&&(h=n-h),u>c||h>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:m,k1:u,k2neg:d,k2:h}}}},St),_e=BigInt(0),ue={};function qt(t,...n){let e=ue[t];if(e===void 0){const r=St(Uint8Array.from(t,i=>i.charCodeAt(0)));e=Y(r,r),ue[t]=e}return St(Y(e,...n))}const $t=t=>t.toRawBytes(!0).slice(1),Yt=t=>ct(t,32),Vt=t=>k(t,xt),Et=t=>k(t,_t),Xt=Rt.ProjectivePoint,gn=(t,n,e)=>Xt.BASE.multiplyAndAddUnsafe(t,n,e);function Dt(t){let n=Rt.utils.normPrivateKeyToScalar(t),e=Xt.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:Et(-n),bytes:$t(e)}}function Oe(t){st("x",t,pt,xt);const n=Vt(t*t),e=Vt(n*t+BigInt(7));let r=Ie(e);r%Ot!==_e&&(r=Vt(-r));const i=new Xt(t,r,pt);return i.assertValidity(),i}const lt=G;function qe(...t){return Et(lt(qt("BIP0340/challenge",...t)))}function mn(t){return Dt(t).bytes}function yn(t,n,e=le(32)){const r=z("message",t),{bytes:i,scalar:o}=Dt(n),c=z("auxRand",e,32),f=Yt(o^lt(qt("BIP0340/aux",c))),s=qt("BIP0340/nonce",f,i,r),u=Et(lt(s));if(u===_e)throw new Error("sign failed: k is zero");const{bytes:h,scalar:m}=Dt(u),d=qe(h,i,r),b=new Uint8Array(64);if(b.set(h,0),b.set(Yt(Et(m+d*o)),32),!Ne(b,r,i))throw new Error("sign: Invalid signature produced");return b}function Ne(t,n,e){const r=z("signature",t,64),i=z("message",n),o=z("publicKey",e,32);try{const c=Oe(lt(o)),f=lt(r.subarray(0,32));if(!yt(f,pt,xt))return!1;const s=lt(r.subarray(32,64));if(!yt(s,pt,_t))return!1;const u=qe(Yt(f),$t(c),i),h=gn(c,s,Et(-u));return!(!h||!h.hasEvenY()||h.toAffine().x!==f)}catch{return!1}}const vn=(()=>({getPublicKey:mn,sign:yn,verify:Ne,utils:{randomPrivateKey:Rt.utils.randomPrivateKey,lift_x:Oe,pointToBytes:$t,numberToBytesBE:ct,bytesToNumberBE:G,taggedHash:qt,mod:k}}))(),bn=(()=>hn(nt,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))))(),pn=(()=>sn(nt,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:nt.create(BigInt("-11"))}))(),Re=(()=>wn(Rt.ProjectivePoint,t=>{const{x:n,y:e}=pn(nt.create(t[0]));return bn(n,e)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:nt.ORDER,m:1,k:128,expand:"xmd",hash:St}))(),xn=(()=>Re.hashToCurve)(),Bn=(()=>Re.encodeToCurve)();export{Bn as encodeToCurve,xn as hashToCurve,vn as schnorr,Rt as secp256k1};
//# sourceMappingURL=secp256k1-0758785a.js.map
